                                     GRADER

Name of student running submit: Oleksiy Budilovsky   
Login of student running submit: cs61b-jp

Second team member's name: Victor Yu
Second team member's login: cs61b-dj

Third team member's name (if any): Marvin Thielk
Third team member's login: cs61b-kt

IMPORTANT:  Once you've submitted Project 2 once, the same team member should
submit always.  If a different teammate must submit, inform cs61b@cory.eecs of
all the details.  Include a complete list of team members, and let us know
which submission you want graded.

If you've submitted your project once, or even written a substantial amount of
code together, you may not change partners without the permission of the
instructor.
===============================================================================
Does your program compile without errors?
Yes.

Have you tested your program on the machines in the Soda CS 61B lab?
Yes.

Did you successfully implement game tree search?  Did you successfully
implement alpha-beta pruning?  Are there any limitations on it?  What is the
default number of search levels set by the one-parameter MachinePlayer
constructor?
Yes, yes, and no limitations. The default number of search levels is 1.  Although our program works fine at search depth 2, we did not implement variable search depth for step moves, and for this reason Test3 in the autograder gives us an error 'CPU Limit exceeded'. For add moves, at search depth 2 our program places moves in about 5 seconds.


Describe your board evaluation function in some detail.
To evaluate the board, we call features() starting from all 4 goals.  features() is similar to is hasValidNetwork() and traverses the entire network tree if there is not a valid network.  If there is a valid network evaluation returns MAXEVAL or MINEVAL depending on who won.  Otherwise, features returns the maximum network length from the goal it was called on squared, number of network nodes expanded, and the closest it gets to the middle of the opposite goal stored as manhattan distance.  Evaluation() multiplies these numbers by constants currently set to 1 and -1 and then adds them together.

Does your MachinePlayer use any special method of choosing the first few moves?
not besides using the evaluation function which causes it to move in middle area of a goal.

Is there anything else the graders should know to help them read your project?
debugPrint statemtnts are spread throughout, but turned off.  Useful output can be generated by setting DEBUG to true;


Describe the classes, modules, and interfaces you designed before and while you
implemented the project.  Your description should include:
 -  A list of the classes your program uses.
 -  A list of each of the "modules" used in or by MachinePlayer, similar to
    the list in the "Teamwork" section of the README (but hopefully more
    detailed).
 -  For each module, list the class(es) the module is implemented in.
 -  For each module, say which of your team members implemented it.
 -  For each module, describe its interface--specifically, the prototype and
    behavior of each method that is available for external callers (outside
    the module) to call.  Don't include methods that are only meant to be
    called from within the module.

    For each method, provide (1) a method prototype and (2) a complete,
    unambiguous description of the behavior of the method/module.  This
    description should also appear before the method in your code's comments.

You will probably need to change some of your design decisions as you go; be
sure to modify this file to reflect these changes before you submit your
project.  Your design of classes and interfaces with be worth about 10% of your
grade.

List of Classes:
MachinePlayer
GameState // contains modules 1-5, is a record of the game board and chips on board
Move
Board //holds 2D int array representation of the game board
SList
SListNode
Coordinate //two ints, x and y, allows us to return two ints representing coordinates for the
                   position
NetworkNode //contains the current coordinate, as well as a pointer to the parent NetworkNode.
                      //Essentially a reverse SList of Coordinate objects, which lets us form networks
                      //store them
Best  //allows us to store a Move and a score associated with that move
               

List of Modules:
1. protected boolean isValidMove(Move m, int side); //in GameState  
2. public SList validMoves(int side); //in GameState, returns an SList of Move objects
3. protected SList networkNeighbors(Coordinate c); //in GameState, returns SList of Coordinates+direction
4. protected boolean hasValidNetwork(int side); //in GameState, breadth-first search
5. public double evaluation(int side); //in GameState
6. protected move minimax(gameState currentState, int depth); //in MachinePlayer

public boolean move(Move m, int side) //in GameState
// If the Move m is legal, records the move as a move by side
// (updates the internal game board) and returns true.  If the move is
// illegal, returns false without modifying the internal state of "this"

public boolean unmove(Move m, int side) //in GameState
// undoes what move does.  returns true if it can undo the Move m, returns false w/out modifying
// 'this' otherwise

1,2: Victor
3,4: Alex
5,6: Marvin


Interfaces:

/**
* isValidMove() determines whether the given 'move' is valid for
* player 'side'.
* @param m is a specific move the player wants to make,
* which will be a position on the GameBoard.
* @param side is the GameState.BLACK or  
* GameState.WHITE
* @return true if the move is valid for player 'side',
* otherwise false.
**/
protected boolean isValidMove(Move m, int side);

/**
 * validMoves() generates a SList of valid moves for
 * the player 'side'. A full description of what constitutes a
 * valid move can be found in the project readme file.
 * @param side is the GameState.BLACK or WHITE
 * @return a SList that contains Coordinate objects of
 * such valid moves, null if no valid moves are found.
public SList validMoves(int side);

 /**
  * hasValidNetwork() determines if Board has a valid network. if side !=
  * GameState.WHITE || GameState.BLACK return false.
  *
  * @param side
  *            is GameState.BLACK || GameState.WHITE
  * @return true if player side has winning network in this board, and false
  *         otherwise.
  **/
 protected SList networkNeighbors(NetworkNode parent);

/**
* hasValidNetwork() determines if Board has a valid network.
* if side != GameState.WHITE || GameState.BLACK return
* false.
* @param side is GameState.BLACK || GameState.WHITE
* @return true if player side has winning network in this board, and
           false otherwise.
**/
protected boolean hasValidNetwork(int side);

/**
*  minimax() returns the best move as determined by minimax
*  @return move determined by minimax algorithm
**/
protected move minimax();

/**
* evaluation() returns a double that is a representation of how good
* the state is for the player indicated by side
* @param side is the side the evaluation is for.  i.e. higher for
* better states for that side
* @return double of calculated evaluation function of the game
* state
**/
public double evaluation(int side);
